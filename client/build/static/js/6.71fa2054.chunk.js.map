{"version":3,"sources":["components/codeBack.js","components/BackCode.js"],"names":["module","exports","BackCode","console","log","className","codeBack","React","memo"],"mappings":"kFA4QAA,EAAOC,QA5QO,yvP,gCCAd,mDAGA,SAASC,IAGP,OAFAC,QAAQC,IAAI,oBAGV,qBAAKC,UAAU,WAAf,SACE,+BAAOC,QAKEC,cAAMC,KAAKN","file":"static/js/6.71fa2054.chunk.js","sourcesContent":["const codeBack = `\r\n\r\n/* server.js - file responsible for setting backend port,\r\n catching requests coming from frontend and re-direct them to controller.js throught routes */\r\n\r\n const express = require(\"express\");\r\n const path = require(\"path\");\r\n const cors = require(\"cors\");\r\n \r\n const routes = require(\"./routes/routes\");\r\n \r\n // Create a new express application named 'app'\r\n const app = express();\r\n \r\n // Set our backend port to be either an environment variable or port 5000\r\n const port = process.env.PORT || 5000;\r\n\r\n// This application level middleware prints incoming requests to the servers console, useful to see incoming requests\r\napp.use((req, res, next) => {\r\n  console.log(\"Request_Endpoint: \"+ req.method +\" \" +req.url\");\r\n  next();\r\n});\r\n\r\n// direct request through routes\r\napp.use(\"/api\", routes);\r\n\r\napp.use(express.json());\r\napp.use(express.urlencoded({ extended: true }));\r\n\r\napp.use(cors());\r\n\r\n// This middleware informs the express application to serve our compiled React files\r\nif (\r\n  process.env.NODE_ENV === \"production\" ||\r\n  process.env.NODE_ENV === \"staging\"\r\n) {\r\n  app.use(express.static(path.join(__dirname, \"./client/build\")));\r\n\r\n  // All other GET requests not handled before will return our React app\r\n  app.get(\"*\", (req, res) => {\r\n    res.sendFile(path.resolve(__dirname, \"./client/build\", \"index.html\"));\r\n  });\r\n  console.log(\"Use other paths!\");\r\n}\r\n\r\n// Catch any bad requests\r\napp.get(\"*\", (req, res) => {\r\n  res.status(200).json({\r\n    msg: \"Catch All\",\r\n  });\r\n});\r\n\r\napp.use((req, res) => {\r\n  res.status(404).json({ msg: \"404\" });\r\n});\r\n\r\napp.listen(port, () => {\r\n  console.log(\"Server is running at port: \" + port);\r\n});\r\n\r\n\r\n// routes.js  - create router\r\n\r\nconst express = require(\"express\");\r\nconst controller = require(\"../controllers/controller\");\r\n\r\n// create a new instance of Router object - router is like a \"mini-app\" but doesn't do anything, we have to use router inside the app\r\nconst router = express.Router();\r\n\r\nrouter.get(\"/countries\", controller.countries);\r\nrouter.get(\"/exchange\", controller.exchange);\r\n\r\nmodule.exports = router;\r\n\r\n\r\n\r\n// controller.js - \r\n/* handling security issues\r\nincluding validation of incoming api data, sending http requests with queries and handling the received data on the back side and send them back to frontend side */\r\n\r\n\r\nconst axios = require(\"axios\");\r\nconst validator = require(\"validator\");\r\n\r\nconst feedbackInit = {\r\n  amountCheck: {},\r\n  currFromCheck: {},\r\n  currToCheck: {},\r\n  fitCountries: [],\r\n  exchRate: \"\",\r\n  date: \"\",\r\n  inputCorrect: false,\r\n  success: false,\r\n  error: \"\",\r\n};\r\n\r\nlet feedback = { ...feedbackInit };\r\n\r\nconst handleValidation = (val, propName, methodName, min, max) => {\r\n  console.log(\"during validation\");\r\n  return new Promise((resolve, reject) => {\r\n    feedback[propName].incorrect = \"\";\r\n    feedback[propName].ok = \"\";\r\n    const valNoSpaces = val.split(\" \").join(\"\");\r\n\r\n    if (valNoSpaces.length <= 0) {\r\n      feedback[propName].incorrect = \"Please fill in all fields in the form.\";\r\n      feedback[propName].ok = false;\r\n      resolve(false);\r\n    } else {\r\n      if (methodName !== null && !validator[methodName](valNoSpaces)) {\r\n        switch (propName) {\r\n          case \"currFromCheck\":\r\n            feedback[propName].incorrect =\r\n              \"Please use only English letters for currency symbol.\";\r\n            break;\r\n          case \"currToCheck\":\r\n            feedback[propName].incorrect =\r\n              \"Please use only English letters for currency symbol.\";\r\n            break;\r\n          case \"amountCheck\":\r\n            feedback[propName].incorrect =\r\n              \"Please use only numbers for amount.\";\r\n            break;\r\n        }\r\n        feedback[propName].ok = false;\r\n        resolve();\r\n      } else if (!validator.isLength(valNoSpaces, { min: min })) {\r\n        feedback[\r\n          propName\r\n        ].incorrect = 'The currency symbol cannot be shorter than' +min+ 'characters.';\r\n        feedback[propName].ok = false;\r\n        resolve();\r\n      } else if (!validator.isLength(valNoSpaces, { max: max })) {\r\n        feedback[propName].incorrect = \"The currency symbol is too long.\";\r\n        feedback[propName].ok = false;\r\n        resolve();\r\n      } else {\r\n        feedback[propName].ok = true;\r\n        resolve();\r\n      }\r\n    }\r\n  });\r\n};\r\n\r\nconst checkIfValidationSuccess = (feedbackObj) => {\r\n  return new Promise((resolve, reject) => {\r\n    let successCheckArr = [];\r\n    for (singleProp in feedbackObj) {\r\n      if (feedbackObj[singleProp].hasOwnProperty(\"ok\")) {\r\n        successCheckArr.push(feedbackObj[singleProp].ok);\r\n      }\r\n    }\r\n    resolve(successCheckArr);\r\n  });\r\n};\r\n\r\nconst countries = async (req, res, next) => {\r\n\r\n  await handleValidation(req.query.toCurrency, \"currToCheck\", \"isAlpha\", 3, 3);\r\n\r\n  if (feedback.currToCheck.ok === true) {\r\n    feedback.inputCorrect = true;\r\n    axios\r\n      .get(req.query.urlAddress)\r\n      .then((response, err) => {\r\n        if (err) {\r\n          feedback.success = false;\r\n          throw new Error(err);\r\n        } else {\r\n          feedback.success = true;\r\n\r\n          const fitCountries = response.data.map(\r\n            (country) => \" \" + country.name\r\n          );\r\n          feedback.fitCountries = fitCountries;\r\n          res.json(feedback);\r\n          feedback = { ...feedbackInit };\r\n          return;\r\n        }\r\n      })\r\n      .catch((err) => {\r\n        if (err.hostname) {\r\n          feedback.error = 'Not able to connect with' +err.hostname;\r\n        } else {\r\n          feedback.error = 'Unable to connect with' + err;\r\n        }\r\n        feedback.success = false;\r\n        res.json(feedback);\r\n        return;\r\n      });\r\n  } else {\r\n    feedback.success = false;\r\n    feedback.inputCorrect = false;\r\n    res.json(feedback);\r\n    feedback = { ...feedbackInit };\r\n    throw new Error(\"Some input has incorrect value!\");\r\n  }\r\n};\r\n\r\nconst exchange = async (req, res) => {\r\n  const toCurr = req.query.toCurrency;\r\n  const fromCurr = req.query.fromCurrency;\r\n  const figure = req.query.amount;\r\n\r\n  await handleValidation(fromCurr, \"currFromCheck\", \"isAlpha\", 3, 3);\r\n  await handleValidation(figure, \"amountCheck\", \"isNumeric\", 1, 7);\r\n\r\n  // check if validation of all values was success\r\n  const successArray = await checkIfValidationSuccess(feedback);\r\n\r\n  // if there are no errors in input fields\r\n  if (successArray.every((el) => el === true)) {\r\n    feedback.inputCorrect = true;\r\n    axios\r\n      .get(req.query.urlAddress)\r\n      .then((response, err) => {\r\n        if (err) {\r\n          feedback.success = false;\r\n          throw new Error(err);\r\n        } else {\r\n          feedback.success = true;\r\n          const rate = response.data.rates;\r\n          let rateFrom, rateTo;\r\n          if (fromCurr === \"EUR\") {\r\n            rateFrom = 1;\r\n          } else {\r\n            rateFrom = rate[fromCurr];\r\n          }\r\n          if (toCurr === \"EUR\") {\r\n            rateTo = 1;\r\n          } else {\r\n            rateTo = rate[toCurr];\r\n          }\r\n          const euro = 1 / rateFrom;\r\n          const exchangeRate = euro * rateTo;\r\n          feedback.exchRate = exchangeRate;\r\n          feedback.date = response.data.date;\r\n          res.json(feedback);\r\n          feedback = { ...feedbackInit };\r\n          return;\r\n        }\r\n      })\r\n      .catch((err) => {\r\n        feedback.success = false;\r\n        if (err.hostname) {\r\n          feedback.error = 'Unable to connect with '+err.hostname;\r\n        } else {\r\n          feedback.error = 'Something went wrong!' +err;\r\n        }\r\n        res.json(feedback);\r\n        feedback = { ...feedbackInit };\r\n        return;\r\n      });\r\n  } else {\r\n    feedback.success = false;\r\n    feedback.inputCorrect = false;\r\n    res.json(feedback);\r\n    feedback = { ...feedbackInit };\r\n    throw new Error(\"Some input has incorrect value!\");\r\n    // return;\r\n  }\r\n};\r\n\r\nmodule.exports = { countries, exchange };\r\n\r\n`;\r\n\r\nmodule.exports = codeBack;\r\n","import React from \"react\";\r\nimport codeBack from \"./codeBack\";\r\n\r\nfunction BackCode() {\r\n  console.log(\"BackCode render!\");\r\n\r\n  return (\r\n    <pre className=\"pre-code\">\r\n      <code>{codeBack}</code>\r\n    </pre>\r\n  );\r\n}\r\n\r\nexport default React.memo(BackCode);\r\n"],"sourceRoot":""}